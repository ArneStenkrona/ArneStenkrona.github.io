I"/<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=AM_CHTML"></script>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/default.min.css" />

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>

<p>
I find my self often returning to the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a>. It is perhaps the most famous example of a fractal with possible exception of the <a href="https://en.wikipedia.org/wiki/SierpiÅ„ski_triangle">Sierpinski triangle</a> and <a href="https://en.wikipedia.org/wiki/Koch_snowflake">Koch Snowflake</a>.
</p>

<p>
While it is visually very impressive, the mathematics behind it is stunningly simple. I will quickly recap, assuming you have a basic understanding of complex numbers and limits.
</p>

<p>
The Mandelbrot set is simply the set of all complex numbers `c` that remain bounded when iterated through the function `f_c(z) = z^2 + c` where `z=0` initially. I.e, all complex numbers for which the sequence `|f_c(0)|,|f_c(f_c(0))|...` does not tend towards infinity.
</p>

<p>
In order to visualize the Mandelbrot set we can draw the two-dimensional complex plane and simply paint all points in the set black, and all not in the set white. <a href="https://www.shadertoy.com/">shader toy</a> is an excellent tool to quickly get this task done. It allows you to quickly write some shader code using GLSL, which is then outputted on a WebGL canvas. A big advantage with writing our visualisation in GLSL is that we are writing code for execution on the GPU. That means we are getting the performance boost of hardware acceleration. Just enter the shader toy website and press <a href="https://www.shadertoy.com/new"><i>new</i></a>.
</p>

<p>
Shader code can be confusing if you've never dealt with it before. In shader toy, we're writing a pixel shader (often called fragment shader). This means that we are writing a function which is going to be executed once for each pixel in the output image. If we associate each pixel with a point in the complex plane, should be able to determine wether or not a pixel is a member of the Mandelbrot set. In order for the programmer to keep track of where we are on the screen, we are supplied with function parameters. Our function signature is as follows:
</p>

<p>
    <pre style="background-color: #ffffffcc; border-radius: 5px;"><code class="language-glsl"> 
    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        ...
    }
    </code>
    </pre>
</p>

<p>
 <i>fragColor</i> is our output color in RGBA format. <i>fragCoord</i> is the pixel coordinate of the pixel which is currently passed to the function. The range of the pixel coordinates will depend on resolution. Therefore we would like to convert them to a more screen independent unit. 
 </p>

<p>
 Luckily shader toy supplies use with some uniform values, which can be found under <i>Shader Inputs</i>. These are read-only globals set by the underlying application which calls our shader program. Among them we find <i>uniform vec3 iResolution</i>, a three component integer vector, where the x and y components correspond to our output width and height in pixels. We can use the resolution to convert the pixel coordinates to something more suitable.
</p>

<p>
A reasonably range for the Mandelbrot is `[-2,2]` on the real x-axis. For the imaginary y-axis we simply ensure that the scale is consistent with the x-axis. We can convert the coordinates as follows:
</p>

<p>
    <pre style="background-color: #ffffffcc; border-radius: 5px;"><code class="language-glsl"> 
    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        float aspectRatio = IResolution.x / iResolution.y;
        float x = 2.0 * (2.0 * (fragCoord.x / iResolution.x) - 1.0);
        float y = 2.0 * (1.0 / aspectRatio) * (2.0 * (fragCoord.y / iResolution.y) - 1.0);
        ...
    }
    </code>
    </pre>
</p>

<p>With our more reasonably scaled pixel coordinate we are ready to determine wether or not the complex number corresponding to the pixel is in the Mandelbrot set. Since determing the limit of infinite iteration through brute force could potentially take an infinite amount of time we will use two tricks. The first is that we note that if `|z| &gt; 2` then `z` is guaranteed to grow without bound (proof left to reader). The second is the technically incorrect assumption that if  `|z|` is still less than or equal to 2 after say 200 iterations, then it will never tend towards infinity. While not always correct, the result is good enough for the visualisation.</p>

<p>
Expressed in GLSL this scheme looks like this:
</p>

<p>
    <pre style="background-color: #ffffffcc; border-radius: 5px;"><code class="language-glsl"> 
    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        ...
        bool diverged = false;
        float x0 = x;
        float y0 = y;
        int i;
        for (i = 0; i &lt; 200; ++i) {
            if (x*x + y*y &gt; 2.0*2.0) {
                diverged = true;
                break;
            }
            float xtemp = x*x - y*y + x0;
            y = 2.0 * x * y + y0;
            x = xtemp;
        }
    }
    </code>
    </pre>
</p>

<p>
Now we simply color the pixel based on wether or not it diverged:
</p>

<p>
    <pre style="background-color: #ffffffcc; border-radius: 5px;"><code class="language-glsl"> 
    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        ...
        vec3 col;
        if (diverged) {
            col = vec3(1.0, 1.0, 1.0); // white
        } else {
            col = vec3(0.0, 0.0, 0.0); // black
        }

        // output color to screen
        fragColor = vec4(col, 1.0);
    }
    </code>
    </pre>
</p>

<p>This gives us a clean, black and white image of the Mandelbrot set:</p>

<p>
While the Mandelbrot is always visually interesting, this binary color scheme can feel a bit underwhelming. In order to make it even more appealing we can use the rate of divergence to choose the color from a palette, Calculatting the rate of divergence is difficult, but the number of iterations before divergence can be used as a rough estimate instead.
</p>

<p>
We start by declaring our palette as an array of <i>vec3</i>, where each array member represents the RGB values of the palette:
</p>

<p>
    <pre style="background-color: #ffffffcc; border-radius: 5px;"><code class="language-glsl"> 
    const vec3 palette[8] = vec3[8](vec3(0.0, 0.0, 0.0)),
                                    vec3(0.5, 0.5, 0.5)),
                                    vec3(1.0, 0.5, 0.5)),
                                    vec3(0.5, 1.0, 0.5)),
                                    vec3(0.5, 0.5, 1.0)),
                                    vec3(0.5, 1.0, 1.0)),
                                    vec3(1.0, 0.5, 1.0)),
                                    vec3(1.0, 1.0, 0.5)));
    </code>
    </pre>
</p>
:ET